#!/usr/bin/env node
var lt=Object.defineProperty;var c=(i,t)=>lt(i,"name",{value:t,configurable:!0});import{StdioServerTransport as Gt}from"@modelcontextprotocol/sdk/server/stdio.js";import{Server as Ft}from"@modelcontextprotocol/sdk/server/index.js";import{CallToolRequestSchema as Bt,ListToolsRequestSchema as Mt}from"@modelcontextprotocol/sdk/types.js";import zt from"ajv";var G="1.0.0",Z="QA Agent";import F from"fs";import ct from"os";import ee from"path";var me=c(i=>(...t)=>{F.appendFileSync(i,`[${new Date().toISOString()}] ${Array.isArray(t)?t.join(" "):t}
`)},"logToFile"),s=me("/tmp/mcp-evaluator-debug.log");function te(){switch(ct.platform()){case"darwin":return"macos";case"win32":case"cygwin":return"windows";case"linux":case"android":return"linux";case"aix":case"freebsd":case"openbsd":case"netbsd":case"sunos":case"haiku":default:return"unix"}}c(te,"getOSName");function fe(i){return typeof i=="string"?i:""}c(fe,"safeString");function k(i,t){if(!i||typeof i!="string"||!t||typeof t!="string")return!1;try{return i.toLowerCase().includes(t.toLowerCase())}catch{return!1}}c(k,"safeIncludes");function ut(){try{let i=fe(process.argv?.[0]),t=fe(process.execPath),e=fe(process.env._);return{name:i.toLowerCase(),execPath:t.toLowerCase(),argv0:e.toLowerCase()}}catch{return{name:"",execPath:"",argv0:""}}}c(ut,"getProcessInfo");function Oe(){try{let i=process.env||{},t=ut();if(i.VSCODE_PID||i.VSCODE_CWD||i.VSCODE_INJECTION||i.VSCODE_IPC_HOOK||i.VSCODE_IPC_HOOK_CLI)return k(t.name,"cursor")||k(t.execPath,"cursor")||k(t.argv0,"cursor")||i.CURSOR_USER_DATA_DIR||i.CURSOR_LOGS_DIR?"cursor":"vscode";if(i.TERM_PROGRAM&&typeof i.TERM_PROGRAM=="string")try{switch(i.TERM_PROGRAM.toLowerCase()){case"cursor":return"cursor";case"vscode":return"vscode";case"iterm.app":case"apple_terminal":case"hyper":case"wezterm":case"alacritty":return"terminal"}}catch{}if(i.VIMRUNTIME||i.VIM)return"vim";if(i.INSIDE_EMACS)return"emacs";if(["idea","webstorm","pycharm","phpstorm","intellij"].some(o=>k(t.name,o)||k(t.execPath,o)||k(t.argv0,o))||k(t.execPath,"jetbrains"))return"jetbrains";if(k(t.name,"sublime")||k(t.execPath,"sublime")||k(t.argv0,"sublime"))return"sublime";if(i.TERM&&typeof i.TERM=="string"){if(i.SSH_CLIENT||i.SSH_TTY||i.SSH_CONNECTION)return"terminal";try{let o=i.TERM.toLowerCase();if(o.includes("xterm")||o.includes("screen")||o.includes("tmux")||o==="linux"||o==="vt100"||o==="vt102")return"terminal"}catch{}}return"terminal"}catch{return"terminal"}}c(Oe,"getCodingPlatform");var ke=c(async(i,t,e)=>{let r=new Array(i.length),o=new Set,a=!1,u=-1,f=c(async()=>{try{let l=i.map((p,m)=>m).filter(p=>!o.has(p));l.length>0&&await e(l)}catch(l){console.error("onAborted failed: ",l)}},"abortRemaining");return new Promise((l,p)=>{i.forEach((m,d)=>{m.then(async w=>{if(!a){o.add(d),r[d]=w;try{await t(d,w)?o.size===i.length&&l(r):(a=!0,u=d,await f(),l([r[u]]))}catch(b){await f(),p(b)}}}).catch(async w=>{a||(a=!0,o.add(d),await f(),p(w))})})})},"failFast"),Ue=process.env.JEST_WORKER_ID!==void 0||!1,v=c(i=>JSON.stringify({message:i.message,stack:i.stack}),"stringifyError"),se=c((i,t,e="s")=>i>0&&i<=1?t:`${t}${e}`,"toPlural"),dt=c((i,t)=>{let e=ee.join(i,".debug"),r=ee.join(e,"screenshots",t);return F.existsSync(e)||F.mkdirSync(e,{recursive:!0}),F.existsSync(r)||F.mkdirSync(r,{recursive:!0}),{debugRoot:e,screenshotsDir:r}},"createDebugFolder"),Le=c((i,t,e,r,o)=>{let{screenshotsDir:a}=dt(i,t),u=ee.join(a,e);F.existsSync(u)||F.mkdirSync(u,{recursive:!0});let l=Date.now().toString().slice(-4),p=`step-${r}-${l}.base64`,m=ee.join(u,p);try{return F.writeFileSync(m,o,"utf8"),s(`[DEBUG] Screenshot saved: ${m}`),m}catch(d){throw s(`[DEBUG] Failed to save screenshot: ${v(d)}`),d}},"saveScreenshot");import pt from"puppeteer";import*as Fe from"readline";var ge=class{static{c(this,"BrowserRegistry")}browsers=new Map;cleanupInProgress=!1;registryId=0;handlingError=!1;cleanupTimeout=5e3;rlInterface;constructor(t=5e3){this.cleanupTimeout=t,this.setupProcessHandlers()}setupProcessHandlers(){let t=["SIGINT","SIGTERM","SIGQUIT","SIGABRT","SIGHUP"];for(let e of t)process.on(e,()=>{s(`[BrowserRegistry] Received ${e}, cleaning up browsers...`),this.safeCleanupAndExit(0,`${e} signal`)});process.platform==="win32"&&(this.rlInterface=Fe.createInterface({input:process.stdin,output:process.stdout}),this.rlInterface.on("SIGINT",()=>{s("[BrowserRegistry] Received SIGINT (Windows), cleaning up browsers..."),this.safeCleanupAndExit(0,"Windows SIGINT")})),process.on("uncaughtException",e=>{if(this.handlingError){console.error("[BrowserRegistry] Fatal: Error during error handling:",e),process.exit(1);return}this.handlingError=!0,s(`[BrowserRegistry] Uncaught exception: ${v(e)}`),this.safeCleanupAndExit(1,"uncaught exception")}),process.on("unhandledRejection",e=>{if(this.handlingError){console.error("[BrowserRegistry] Fatal: Unhandled rejection during error handling:",e),process.exit(1);return}this.handlingError=!0,s(`[BrowserRegistry] Unhandled promise rejection: ${v(e)}`),this.safeCleanupAndExit(1,"unhandled rejection")}),process.on("beforeExit",e=>{this.browsers.size>0&&!this.cleanupInProgress&&!this.handlingError&&(s(`[BrowserRegistry] beforeExit triggered with code ${e}, ${this.browsers.size} browsers still open`),this.safeCleanupAndExit(e,"beforeExit"))}),process.on("exit",e=>{if(s(`[BrowserRegistry] Process exiting with code ${e}`),this.browsers.size>0){s(`[BrowserRegistry] WARNING: ${this.browsers.size} browsers still registered at exit!`);let r=Array.from(this.browsers.values()).map(o=>`${o.id}: ${o.description}`).join(", ");s(`[BrowserRegistry] Open browsers: ${r}`)}this.rlInterface&&this.rlInterface.close()}),s(`[BrowserRegistry] Process handlers initialized (cleanup timeout: ${this.cleanupTimeout}ms)`)}async safeCleanupAndExit(t,e){if(this.cleanupInProgress){s(`[BrowserRegistry] Cleanup already in progress for ${e}, waiting...`);return}try{await this.cleanup(),s(`[BrowserRegistry] Cleanup complete for ${e}`)}catch(r){s(`[BrowserRegistry] Cleanup failed for ${e}: ${v(r)}`)}finally{process.exit(t)}}register(t,e){let r=`browser-${++this.registryId}`;return this.browsers.set(r,{id:r,browser:t,description:e,registeredAt:Date.now()}),s(`[BrowserRegistry] Registered browser ${r}: ${e} (total: ${this.browsers.size})`),r}unregister(t){let e=this.browsers.get(t);e&&(this.browsers.delete(t),s(`[BrowserRegistry] Unregistered browser ${t}: ${e.description} (total: ${this.browsers.size})`))}getCount(){return this.browsers.size}getRegisteredBrowsers(){let t=Date.now();return Array.from(this.browsers.values()).map(e=>({id:e.id,description:e.description,registeredAt:e.registeredAt,ageMs:t-e.registeredAt}))}async cleanup(){if(this.cleanupInProgress){s("[BrowserRegistry] Cleanup already in progress, skipping...");return}this.cleanupInProgress=!0;let t=this.browsers.size;if(t===0){s("[BrowserRegistry] No browsers to cleanup");return}s(`[BrowserRegistry] Starting cleanup of ${t} browsers...`);let e=Array.from(this.browsers.values()).map(async o=>{let a=Date.now();try{s(`[BrowserRegistry] Closing browser ${o.id}: ${o.description} (age: ${a-o.registeredAt}ms)`),await o.browser.close();let u=Date.now()-a;s(`[BrowserRegistry] Successfully closed browser ${o.id} in ${u}ms`)}catch(u){let f=Date.now()-a;s(`[BrowserRegistry] Error closing browser ${o.id} after ${f}ms: ${v(u)}`)}}),r=new Promise((o,a)=>setTimeout(()=>a(new Error(`Cleanup timeout after ${this.cleanupTimeout}ms`)),this.cleanupTimeout));try{await Promise.race([Promise.allSettled(e),r]),s(`[BrowserRegistry] Normal cleanup complete. All ${t} browsers have been processed.`)}catch{s("[BrowserRegistry] Cleanup timed out, initiating force kill..."),await this.forceKill()}finally{this.browsers.clear(),this.cleanupInProgress=!1}}async forceKill(){s(`[BrowserRegistry] Force killing ${this.browsers.size} browser processes...`);let t=Array.from(this.browsers.values()).map(async e=>{try{let r=e.browser.process();r&&!r.killed?(r.kill("SIGTERM"),await new Promise(o=>setTimeout(o,100)),r.killed?s(`[BrowserRegistry] Browser process ${e.id} terminated with SIGTERM`):(r.kill("SIGKILL"),s(`[BrowserRegistry] Force killed browser process ${e.id} with SIGKILL`))):s(`[BrowserRegistry] Browser process ${e.id} already dead`)}catch(r){s(`[BrowserRegistry] Error force killing browser ${e.id}: ${v(r)}`)}});await Promise.allSettled(t),this.browsers.clear(),s("[BrowserRegistry] Force kill complete")}getDiagnostics(){let t=Date.now();return{browserCount:this.browsers.size,cleanupInProgress:this.cleanupInProgress,handlingError:this.handlingError,browsers:Array.from(this.browsers.values()).map(e=>{let r=!1;try{let o=e.browser.process();r=o?!o.killed:!1}catch{r=!1}return{id:e.id,description:e.description,ageMs:t-e.registeredAt,processAlive:r}})}}},B=new ge(5e3);import Be from"datadog-metrics";var j=me("/tmp/mcp-evaluator-profiling.log"),he=class{static{c(this,"Profiler")}timers=new Map;datadogEnabled;constructor(){this.datadogEnabled=!!process.env.DATADOG_API_KEY,this.datadogEnabled&&(Be.init({apiKey:process.env.DATADOG_API_KEY,prefix:"mcp_evaluator_optimizer.",defaultTags:["service:mcp-evaluator-optimizer","env:production"],onError:c(t=>j(`[PROFILING] DataDog error: ${t}`),"onError")}),j("[PROFILING] DataDog profiler initialized"))}createUniqueKey(t,e){if(!e||!e.uid)throw new Error(`[PROFILING] CRITICAL: UID is required for all profiler operations. Operation: ${t}`);return`${t}-${e.uid}`}start(t,e){let r=this.createUniqueKey(t,e),o=this.formatContext(e);this.timers.set(r,{start:Date.now(),context:e}),j(`[PROFILING] START ${t}${o}`)}end(t,e){let r=this.createUniqueKey(t,e),o=this.timers.get(r);if(!o){j(`[PROFILING] ERROR: No timer found for ${t}`);return}let a=Date.now()-o.start,u={...o.context,...e},f=this.formatContext(u);j(`[PROFILING] END ${t}${f} - Duration: ${a}ms`),this.sendToDataDog(t,a,u),this.timers.delete(r)}formatContext(t){let e=[];return t.runId&&e.push(`runId=${t.runId}`),Object.keys(t).forEach(r=>{["runId"].includes(r)||e.push(`${r}=${t[r]}`)}),e.length>0?` [${e.join(", ")}]`:""}sendToDataDog(t,e,r){if(this.datadogEnabled)try{let o=t.replace(/[^a-zA-Z0-9_]/g,"_"),a=[];Be.histogram(o,e,a)}catch(o){j(`[PROFILING] Failed to send DataDog metric: ${o}`)}}},n=new he;var re=class{static{c(this,"PageFreezer")}page;client;freezeTimestamp=0;isPaused=!1;async initialize(t){return this.page=t,this.client=await t.createCDPSession(),await this.client.send("Debugger.enable"),this.client.on("Debugger.paused",()=>{this.isPaused=!0}),this.client.on("Debugger.resumed",()=>{this.isPaused=!1}),this}async freeze(){if(!this.client||!this.page)throw new Error("PageFreezer not initialized");if(!this.freezeTimestamp){this.freezeTimestamp=Date.now();let t=new Promise(e=>{if(this.isPaused){e();return}let r=c(()=>{this.client.off("Debugger.paused",r),e()},"listener");this.client.on("Debugger.paused",r)});this.client.send("Runtime.evaluate",{expression:`
                    (function() {
                        window.__freezeLoopActive = true;
                        while (window.__freezeLoopActive) {
                            // This loop will run until Debugger.pause stops it
                        }
                    })();
                `,awaitPromise:!1,userGesture:!0}).catch(()=>{}),await new Promise(e=>setTimeout(e,10)),await this.client.send("Debugger.pause"),await t,await this.client.send("Runtime.evaluate",{expression:"delete window.__freezeLoopActive;",awaitPromise:!1}).catch(()=>{}),await this.client.send("Animation.enable"),await this.client.send("Animation.setPlaybackRate",{playbackRate:0})}return this}async unfreeze(){if(!this.client)throw new Error("PageFreezer not initialized");if(this.freezeTimestamp){await this.client.send("Runtime.evaluate",{expression:"window.__freezeLoopActive = false;",awaitPromise:!1}).catch(()=>{});do try{await this.client.send("Debugger.resume"),await new Promise(t=>setTimeout(t,100))}catch(t){s(v(t))}while(this.isPaused);await this.client.send("Animation.setPlaybackRate",{playbackRate:1}),this.freezeTimestamp=0}return this}async cleanup(){this.client&&(await this.unfreeze(),await this.client.send("Debugger.disable"),await this.client.send("Animation.disable"),this.client=void 0,this.page=void 0)}};var we=!0,ie=class{static{c(this,"BrowserController")}session;webappUrl;headless;browser;page;registryId;freezer;devicePixelRatio;constructor(t,e,r=!0){if(this.session=t,!e)throw new Error(`Invalid Webapp URL: "${e}"`);this.webappUrl=e,this.headless=r}async launchBrowser(){if(s(`[BrowserController] Launching  Puppeteer browser for session ${this.session.session_uid}`),this.browser)throw new Error("Browser already launched");let t=this.session.session_uid,e=this.session.test_id;n.start("browser-launch",{uid:t,testId:e}),this.browser=await pt.launch({headless:this.headless,defaultViewport:null,args:["--disable-extensions","--disable-plugins","--disable-dev-shm-usage","--disable-gpu","--no-first-run","--disable-default-apps","--disable-background-timer-throttling","--disable-backgrounding-occluded-windows","--disable-renderer-backgrounding","--disable-blink-features=AutomationControlled","--disable-features=TranslateUI","--disable-ipc-flooding-protection","--disable-background-networking","--disable-hang-monitor","--disable-prompt-on-repost","--memory-pressure-off"]}),n.end("browser-launch",{uid:t,testId:e,result:"success"}),this.registryId=B.register(this.browser,`BrowserController-${this.session.session_uid}`),n.start("browser-new-page",{uid:t,testId:e}),this.page=await this.browser.newPage(),n.end("browser-new-page",{uid:t,testId:e,result:"success"}),this.freezer=we?await new re().initialize(this.page):void 0,await this.navigateToWebapp(),await this.injectControllerScript(this.session.controller_script),s(`[BrowserController] Browser launched and controller script injected for session ${this.session.session_uid}`)}#e(){if(!this.page)throw new Error("Browser page not initialized")}async navigateToWebapp(){this.#e(),s(`[BrowserController] ${this.session.session_uid} navigating to webapp "${this.webappUrl}" `),n.start("browser-navigate-to-webapp",{uid:this.session.session_uid});try{await this.page.goto(this.webappUrl,{waitUntil:"domcontentloaded",timeout:6e4}),n.end("browser-navigate-to-webapp",{uid:this.session.session_uid})}catch(t){if(n.end("browser-navigate-to-webapp",{uid:this.session.session_uid,result:"error",error:t.message}),s(`[BrowserController] Navigation failed for ${this.webappUrl}: ${t.message}`),this.webappUrl.startsWith("file://")){s("[BrowserController] Retrying file URL navigation with networkidle0");try{await this.page.goto(this.webappUrl,{waitUntil:"networkidle0",timeout:9e4}),s("[BrowserController] File URL navigation succeeded on retry")}catch(e){throw s(`[BrowserController] File URL retry also failed: ${e.message}`),e}}else throw t}}async injectControllerScript(t){this.#e(),n.start("browser-inject-controller-script",{uid:this.session.session_uid}),await this.page.evaluateOnNewDocument(t),await this.page.evaluate(t),await this.page.evaluate(()=>typeof window.__puppeteerResize=="function")||await this.page.exposeFunction("__puppeteerResize",async r=>{await this.page.setViewport(r),await this.page.evaluate(o=>{window.__puppeteerBridge.dispatchEvent(new CustomEvent("viewport-changed",{detail:o}))},r)}),n.end("browser-inject-controller-script",{uid:this.session.session_uid})}async executeScript(t){this.#e(),n.start("browser-execute-script",{uid:this.session.session_uid});try{let e,r=new Promise((o,a)=>{e=setTimeout(()=>{a(new Error("Script execution timed out after 10 seconds"))},1e4)});try{await Promise.race([this.page.evaluate(t),r])}finally{clearTimeout(e)}n.end("browser-execute-script",{uid:this.session.session_uid})}catch(e){throw n.end("browser-execute-script",{uid:this.session.session_uid,result:e.message}),s(`[BrowserController ${this.session.session_uid}] script execution failed: ${e}`),e}}async focusElement(t){this.#e();let e=`[data-qa-id="${t}"]`;try{n.start("browser-focus-element",{uid:this.session.session_uid,elementId:t}),s(`[BrowserController ${this.session.session_uid}] focusing on element: ${e}`),await this.page.focus(e),n.end("browser-focus-element",{uid:this.session.session_uid,elementId:t,result:"success"}),s(`[BrowserController ${this.session.session_uid}] successfully focused on element: ${e}`)}catch(r){throw n.end("browser-focus-element",{uid:this.session.session_uid,elementId:t,result:r.message}),s(`[BrowserController ${this.session.session_uid}] failed to focus on element ${e}: ${r}`),new Error(`Failed to focus on element with selector "${e}": ${r}`)}}async clickElement(t){this.#e();let e=`[data-qa-id="${t}"]`;try{n.start("browser-click-element",{uid:this.session.session_uid,elementId:t}),s(`[BrowserController ${this.session.session_uid}] clicking on element: ${e}`),await this.page.click(e),n.end("browser-click-element",{uid:this.session.session_uid,elementId:t,result:"success"}),s(`[BrowserController ${this.session.session_uid}] successfully clicked on element: ${e}`)}catch(r){throw n.end("browser-click-element",{uid:this.session.session_uid,elementId:t,result:r.message}),s(`[BrowserController ${this.session.session_uid}] failed to click on element ${e}: ${r}`),new Error(`Failed to click on element with selector "${e}": ${r}`)}}async pressKey(t){this.#e();try{n.start("browser-press-key",{uid:this.session.session_uid,keyCode:t}),s(`[BrowserController] ${this.session.session_uid} pressing key with keyCode: ${t}`);let e;switch(t){case 8:e="Backspace";break;case 9:e="Tab";break;case 13:e="Enter";break;case 27:e="Escape";break;case 32:e="Space";break;case 37:e="ArrowLeft";break;case 38:e="ArrowUp";break;case 39:e="ArrowRight";break;case 40:e="ArrowDown";break;case 46:e="Delete";break;default:if(t>=32&&t<=126)e=String.fromCharCode(t);else throw new Error(`Unsupported keyCode: ${t}`)}await this.page.keyboard.press(e),n.end("browser-press-key",{uid:this.session.session_uid,keyCode:t,result:"success"}),s(`[BrowserController] ${this.session.session_uid} successfully pressed key: ${e} (keyCode: ${t})`)}catch(e){throw n.end("browser-press-key",{uid:this.session.session_uid,keyCode:t,result:e.message}),s(`[BrowserController] ${this.session.session_uid} failed to press key ${t}: ${e}`),new Error(`Failed to press key with keyCode "${t}": ${e}`)}}async takeScreenshot(t){this.#e(),n.start("browser-take-screenshot",{uid:this.session.session_uid});let e=await this.page.createCDPSession(),r=await this.getDevicePixelRatio(),{data:o}=await e.send("Page.captureScreenshot",{format:"png",...t?{clip:{x:t.x0,y:t.y0,width:t.x1-t.x0,height:t.y1-t.y0,scale:r}}:{captureBeyondViewport:!0}});return n.end("browser-take-screenshot",{uid:this.session.session_uid}),o}async extractDOM(){this.#e(),n.start("browser-extract-dom",{uid:this.session.session_uid});let t=await this.page.evaluate(async()=>{try{let e=await window.scrapeDOM();return console.log("[BrowserController] [dom.callback] returning to Node"),e}catch(e){return console.error(`[BrowserController] [dom.callback error]
`,e),{error:e}}});return n.end("browser-extract-dom",{uid:this.session.session_uid,result:t.error?t.error.message:"success"}),t}async getViewportBounds(){this.#e(),n.start("browser-get-viewport-bounds",{uid:this.session.session_uid});let t=await this.page.evaluate(()=>{let e=window.scrollX,r=window.scrollY;return{x0:e,y0:r,x1:e+window.innerWidth,y1:r+window.innerHeight}});return n.end("browser-get-viewport-bounds",{uid:this.session.session_uid}),t}async getDevicePixelRatio(){if(this.#e(),this.devicePixelRatio)return this.devicePixelRatio;n.start("browser-get-device-pixel-ratio",{uid:this.session.session_uid});let t=await this.page.evaluate(()=>window.devicePixelRatio||1);return n.end("browser-get-device-pixel-ratio",{uid:this.session.session_uid}),this.devicePixelRatio=t,t}async resetPageState(){this.#e(),s(`[BrowserController] resetPageState ${this.session.session_uid}`),await this.clearPageState(),await this.navigateToWebapp(),s(`[BrowserController] Re-injecting controller script after reset ${this.session.session_uid}`),this.session.controller_script&&await this.injectControllerScript(this.session.controller_script)}async freezePage(){if(we){if(!this.freezer)throw new Error("Page freezer not initialized");s(`[BrowserController] Freezing page for session ${this.session.session_uid}`),await this.freezer.freeze()}}async unfreezePage(){if(we){if(!this.freezer)throw new Error("Page freezer not initialized");s(`[BrowserController] Unfreezing page for session ${this.session.session_uid}`),await this.freezer.unfreeze()}}async clearPageState(){this.#e();try{n.start("browser-clear-page-state",{uid:this.session.session_uid}),s(`=== [BrowserController] clearPageState ${this.session.session_uid} ===`),await this.page.evaluate(()=>{typeof localStorage<"u"&&localStorage.clear()}),await this.page.evaluate(()=>{typeof sessionStorage<"u"&&sessionStorage.clear()});let t=await this.page.createCDPSession();await t.send("Network.clearBrowserCache"),await t.send("Network.clearBrowserCookies"),await this.page.evaluate(()=>{for(let e=1;e<1e4;e++)clearTimeout(e),clearInterval(e)}),n.end("browser-clear-page-state",{uid:this.session.session_uid,result:"success"})}catch(t){n.end("browser-clear-page-state",{uid:this.session.session_uid,result:t.message}),s(`[BrowserController] clearPageState error ${this.session.session_uid}: ${t}`)}}async cleanup(){s(`=== [BrowserController] cleanup ${this.session.session_uid} ===`);try{this.freezer&&(await this.freezer.cleanup(),this.freezer=void 0),this.browser&&(n.start("browser-cleanup",{uid:this.session.session_uid}),await this.browser.close(),this.browser=void 0,this.page=void 0,n.end("browser-cleanup",{uid:this.session.session_uid,result:"success"}))}catch(t){n.end("browser-cleanup",{uid:this.session.session_uid,result:t.message}),s(`[BrowserController] cleanup error ${this.session.session_uid}: ${t}`)}finally{this.registryId&&(B.unregister(this.registryId),this.registryId=void 0)}}};var y=class i extends Error{static{c(this,"CritiqueError")}#e;constructor(t){super(t.feedbacks?.[0]?.text||"Critique error"),this.name="CritiqueError",this.#e={...t,decision:"CRITIQUE",metadata:{...t.metadata,evaluationTime:Date.now(),evaluatorVersion:G}}}toEvaluationResult(){return this.#e}static fromError(t,e){if(t instanceof i)return t;let r=String(t?.message||t||"Unknown Error");return new i({confidence:.1,feedbacks:[{text:`Error: ${r}`,structured:{violation:`EXECUTION_ERROR: ${r}`,testId:e,severity:"BLOCKING"}}]})}},q=c((i,t)=>{throw i instanceof y?i:t},"bubbleCritiqueErrorOrThrow"),be=c(i=>i instanceof Error&&(i.name==="AbortError"||i.message.includes("timeout")),"isTimeoutError");var ye=class{static{c(this,"ProgressTracker")}state={progressToken:void 0,server:void 0,totalTests:0,completedTests:0};initialize(t){this.state.progressToken=t.progressToken,this.state.server=t.server,s(`[Progress] Initialized with token: ${t.progressToken}`)}setTotalTests(t){this.state.totalTests=t,s(`[Progress] Updated totalTests to: ${t}`)}notify(t,e,r){if(!this.state.progressToken||!this.state.server){s("[Progress] No token or server available, skipping notification");return}let o={progressToken:this.state.progressToken,progress:t,total:e,...r&&{message:r}};s(`[Progress] Notifying: ${t}/${e} - ${r||"no message"}`),this.state.server.notification({method:"notifications/progress",params:o}).catch(a=>{s(`[Progress] Failed to send notification: ${a}`)})}toolCalled(){this.notify(1,100,"Tool called")}toolValidated(){this.notify(2,100,"Tool validation completed")}evaluateStarted(){this.notify(3,100,"Evaluation started")}asyncPrepInitiated(){this.notify(4,100,"Async preparation initiated")}updateAsyncPreparationProgress(t,e){let r=Math.round(5+t/100*15),o=e||`Execution progress: ${t}%`;s(`[Progress] Execution progress ${t}% \u2192 ${r}%`),this.notify(r,100,o)}testsExecutionStarted(){this.notify(20,100,"Test execution started")}incrementCompletedTests(t){if(!this.state.totalTests){s("[Progress] Cannot increment completed tests - totalTests not set");return}this.state.completedTests++;let e=this.state.completedTests/this.state.totalTests,r=Math.round(Math.min(20+e*79,99));s(`[Progress] Test ${this.state.completedTests}/${this.state.totalTests} completed \u2192 ${r}% (testsProgress: ${e.toFixed(3)})`);let o=t||`Test ${this.state.completedTests}/${this.state.totalTests} completed`;this.notify(r,100,o)}complete(){this.notify(100,100,"Evaluation completed"),this.cleanup()}fail(t){this.notify(99,100,`Evaluation failed: ${t||"unknown error"}`)}completeAfterFailure(){this.notify(100,100,"Failed evaluation result returned"),this.cleanup()}cleanup(){this.state={progressToken:void 0,server:void 0,totalTests:0,completedTests:0}}},$=new ye;var Me=3e4,ft=2e3,mt=3,M=class i{static{c(this,"ApiClient")}#e;#s;static apiCalls={initialize:0,async_prep:0,execution_state:0,step:0};constructor(t,e){this.#e=t,this.#s=e}get baseUrl(){return this.#e}async#t(t,e,r){let{timeoutMs:o=Me,context:a}=r,u=this.#s??e.signal;if(o){let p=AbortSignal.timeout(o);u=u?AbortSignal.any([u,p]):p}let f=await fetch(t,{...e,signal:u});if(this.#s?.aborted)throw new Error(`API call aborted: ${a}`);if(!f.ok)throw new Error(`${a} failed: ${f.status}`);let l=await f.json();if(!l)throw new Error(`API call failed, json() returned undefined: ${a}`);return l}async#r(t,e,r){let{maxRetries:o=mt,baseDelay:a=ft,timeoutMs:u=Me,context:f}=r,l,p=0;for(let m=0;m<=o;m++)try{return await this.#t(t,e,{timeoutMs:u,context:f})}catch(d){if(l=d,be(d)&&(p++,this.#s?.aborted))throw d;let w=d.message?.match(/failed: (\d+)/i);if(w){let h=parseInt(w[1]);if(![408,429,500,502,503,504].includes(h))throw d}if(m===o)throw s(`[ApiClient] ${f} failed after ${o+1} attempts. Last error: ${l.message}`),p===o+1?new Error(`Server not responding. Request timed out after ${u/1e3} seconds and was retried ${o} times. Test aborted. `):l;let b=a*Math.pow(2,m);s(`[ApiClient] ${f} attempt ${m+1} failed: ${l.message}. Retrying in ${b}ms...`),await new Promise(h=>setTimeout(h,b))}throw l}async asyncPrep(t){let e=`api-async-prep-${++i.apiCalls.async_prep}-${Date.now()}`;n.start("api-async-prep",{uid:e});let r=await this.#t(`${this.baseUrl}/mgr/api/v1/test-plans/async_prep`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)},{context:"Async QA sessions preparation",timeoutMs:6e4});return n.end("api-async-prep",{uid:e,runId:r.execution_id}),r}async getExecutionState(t){let e=`api-get-execution-state-${++i.apiCalls.execution_state}-${Date.now()}`,r=`${this.baseUrl}/mgr/api/v1/executions/${t}/state`;s(`[ApiClient.getExecutionState] ${e} - Fetching state for runId: ${t}`),s(`[ApiClient.getExecutionState] ${e} - Request URL: ${r}`),n.start("api-get-execution-state",{uid:e,runId:t});let o=await this.#t(r,{method:"GET",headers:{"Content-Type":"application/json"}},{context:"Get execution state",timeoutMs:5e3});return s(`[ApiClient.getExecutionState] ${e} - Full /state response:`),s(`[ApiClient.getExecutionState] ${e} - Response status: ${o.status}`),s(`[ApiClient.getExecutionState] ${e} - Full response body: ${JSON.stringify(o,null,2)}`),n.end("api-get-execution-state",{uid:e,runId:t,status:o.status}),o}async asyncPrepWithStatePolling(t){let e=`api-async-prep-with-polling-${Date.now()}`;n.start("api-async-prep-with-polling",{uid:e});let{execution_id:r}=await this.asyncPrep(t);s(`[ApiClient] Started async prep with runId: ${r}`),$.asyncPrepInitiated();let o=Date.now(),a=10*60*1e3,u=3e3;for(;;){if(Date.now()-o>=a)throw new Error(`Preparing timeout: Test plan preparation exceeded ${a/(60*1e3)} minutes `);try{let l=await this.getExecutionState(r);switch(s(`[ApiClient] Poll ${r}: ${l.status} - ${l.message} (${l.progress_percentage}%)`),$.updateAsyncPreparationProgress(l.progress_percentage,`${l.message} (created ${l.completed_sessions} sessions)`),l.status){case"running":case"completed":{if(!l.sessions)throw s(`[ApiClient] ERROR: Status '${l.status}' but no sessions in state response`),new Error(`'${l.status}' but no sessions`);return s(`[ApiClient] Sessions data received: ${l.sessions.length} sessions`),s(`[ApiClient] Full sessions data: ${JSON.stringify(l.sessions,null,2)}`),{sessions:l.sessions,runId:r}}case"failed":throw new y({confidence:1,feedbacks:[{text:`UNACCEPTABLE: Failed to prepare test plan - ${l.message}. The .vibe/test_plan content appears to be invalid or insufficient.`,structured:{violation:"QA_PLAN_PREPARATION_FAILED",testId:"N/A",severity:"BLOCKING",penalty:"$2000"},suggestions:[{type:"action",content:`Review and fix the .vibe/test_plan file content. Error: ${l.message}`,severity:"BLOCKING"}]}]});case"preparing":break;default:throw new Error(`Unknown execution status: ${l.status}`)}}catch(l){if(l instanceof y)throw l;be(l)?s(`[ApiClient] Poll timeout for ${r}, retrying...`):s(`[ApiClient] Poll error for ${r}: ${v(l)}
retrying...`)}finally{n.end("api-async-prep-with-polling",{uid:e,runId:r})}await new Promise(l=>setTimeout(l,u))}}async step(t,e){let r=`api-step-${++i.apiCalls.step}-${Date.now()}`;n.start("api-step",{uid:r,sessionId:t});let o=await this.#r(`${this.baseUrl}/${t}/step`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)},{context:`[${t}] QA step`});return n.end("api-step",{uid:r,sessionId:t,action:o.action}),o}async abort(t){await this.#t(`${this.baseUrl}/${t}/abort`,{method:"POST",headers:{"Content-Type":"application/json"}},{context:`[${t}] Session abort`})}async initializeTool(t){let e=`api-init-tool-${++i.apiCalls.initialize}-${Date.now()}`;n.start("api-init-tool",{uid:e});let r=await this.#t(`${this.baseUrl}/init_tool`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)},{context:"Tool initialization"});return n.end("api-init-tool",{uid:e,result:"success"}),r}};var oe=class{static{c(this,"EvaluatorTool")}tool=null;initPromise=null;async get(t){return this.tool?this.tool:this.initPromise?this.initPromise:(s("=== [EvaluatorTool] Fetching tool info ==="),this.initPromise=this.#e(t),this.initPromise)}async#e(t){try{let e=await new M(t).initializeTool({os:te(),coding_platform:Oe(),coding_agent:"claude-4-sonnet"}),r={name:e.name,description:e.description,inputSchema:JSON.parse(e.schema)};return this.tool=r,s("=== [EvaluatorTool] Tool info fetched successfully ==="),s(`Tool name: ${r.name}`),s(`Tool description: ${r.description}`),s(`Tool inputSchema: ${JSON.stringify(r.inputSchema,void 0,2)}`),r}catch(e){throw s("[EvaluatorTool] Error fetching tool definition:"),s(v(e)),this.initPromise=null,e}}};import{spawn as gt}from"child_process";var ze=c(i=>{let t=[/url:\s*(https?:\/\/[^\s]+)/i,/Local:\s*(https?:\/\/[^\s]+)/i,/Local:\s*(https?:\/\/localhost:\d+)/i,/(?:server.*?(?:running|started).*?(?:on|at)|listening.*?(?:on|at)).*?(https?:\/\/[^\s]+)/i,/(https?:\/\/localhost:\d+)/i,/(?:port|listening.*?on).*?(\d+)/i];for(let e of t){let r=i.match(e);if(r){let o=r[1];if(/^\d+$/.test(o)&&(o=`http://localhost:${o}`),o.startsWith("http://")||o.startsWith("https://"))return o}}return null},"extractUrlFromOutput");var H=class{static{c(this,"WebappController")}#e;startWebapp=c(async(t,e)=>{let r=`webapp-start-${Date.now()}`;return n.start("webapp-start",{uid:r,command:e}),new Promise((o,a)=>{s(`[WebappController] Starting webapp with command "${e}" in ${t}`);try{let u,f;if(e.startsWith("node -e")){let b=e.match(/^node -e\s+(.+)$/);if(b){let h=b[1],C=h.startsWith('"')&&h.endsWith('"')?h.slice(1,-1):h;u="node",f=["-e",C]}else throw n.end("webapp-start",{uid:r,result:"error",error:"Invalid node -e command"}),new Error(`Invalid node -e command: ${e}`)}else[u,...f]=e.split(" ");n.start("webapp-process-spawn",{uid:r,command:u});let l=gt(u,f,{cwd:t,stdio:["pipe","pipe","pipe"]});n.end("webapp-process-spawn",{uid:r,command:u,result:"success",pid:l.pid});let p=null,m={};n.start("webapp-url-detection",{uid:r});let d=c((b,h={})=>{m.current&&(clearTimeout(m.current),m.current=null);let C=typeof b=="string"?b:b.message,P=typeof b=="string"?new Error(b):b;n.end("webapp-url-detection",{uid:r,result:"error",...h}),n.end("webapp-start",{uid:r,result:"error",error:C,...h}),a(P)},"handleError"),w=c(b=>{let h=ze(b);h&&!p&&(p=h,s(`[WebappController] Detected webapp URL "${h}"`),this.#e={process:l,url:h},m.current&&(clearTimeout(m.current),m.current=null),n.end("webapp-url-detection",{uid:r,result:"success",detectedUrl:h}),n.end("webapp-start",{uid:r,result:"success",url:h}),o(this.#e))},"detectUrl");l.stdout?.on("data",b=>{let h=b.toString();s(`[WebappController] stdout: ${h}`),w(h)}),l.stderr?.on("data",b=>{let h=b.toString();s(`[WebappController] stderr: ${h}`),w(h)}),l.on("error",b=>{s("[WebappController] Error starting webapp process"),s(v(b)),d(b,{source:"process-error"})}),l.on("close",(b,h)=>{s(`Webapp process closed with code ${b} and signal ${h}`),b!==0&&!p&&d(`Webapp process exited with code ${b}`,{exitCode:b,signal:h})}),m.current=setTimeout(()=>{p||(m.current=null,d("Timeout: No webapp URL detected within 30 seconds",{source:"timeout"}))},3e4)}catch(u){n.end("webapp-start",{uid:r,result:"error",error:u.message}),a(u)}})},"startWebapp");stopWebapp=c(()=>new Promise(t=>{if(this.#e&&!this.#e.process.killed){let e=`webapp-stop-${Date.now()}`;n.start("webapp-stop",{uid:e}),s("[WebappController] Stopping webapp process");let r=this.#e.process,o=!1,a=c(()=>{o||(o=!0,n.end("webapp-stop",{uid:e,result:"success",pid:r.pid}),this.#e=void 0,global.gc&&global.gc(),t())},"cleanup");r.once("exit",a),r.kill("SIGTERM"),setTimeout(()=>{!r.killed&&!o&&(s("[WebappController] Process didn't exit gracefully, sending SIGKILL"),r.kill("SIGKILL"))},1e3),setTimeout(()=>{o||(s("[WebappController] Force resolving after timeout"),a())},3e3)}else this.#e=void 0,t()}),"stopWebapp");get webapp(){return this.#e}};import Qe from"fs";var ne=c(async i=>{let t=`webapp-validation-${Date.now()}`;if(i.startsWith("file:///")){n.start("webapp-file-validation",{uid:t,url:i});let e=i.replace("file://",""),{access:r}=Qe.promises;await r(e,Qe.constants.F_OK),n.end("webapp-file-validation",{uid:t,result:"success",filePath:e}),s(`[validateWebappUrl] Confirmed file exists at ${i}`)}else{n.start("webapp-http-validation",{uid:t,url:i});let e=new AbortController,r=setTimeout(()=>e.abort(),2e3),o=await fetch(i,{method:"HEAD",signal:e.signal});if(clearTimeout(r),!o.ok){let a=new Error(`Server responded with status ${o.status}`);throw n.end("webapp-http-validation",{uid:t,result:"error",httpStatus:o.status,error:a.message}),a}s(`[validateWebappUrl] Confirmed server is running at ${i}`),n.end("webapp-http-validation",{uid:t,result:"success",httpStatus:o.status})}},"validateWebappUrl");import je from"path";import J from"fs";import{randomUUID as $t}from"node:crypto";import{cpus as St,freemem as Tt,totalmem as Rt}from"node:os";import{execSync as It}from"node:child_process";import bt from"path";import yt from"fs";import{parse as ht}from"csv-parse";var ae=c(async i=>new Promise(t=>{let e=0,r=!1,o=ht({delimiter:"|",skip_empty_lines:!0,trim:!0});o.on("readable",function(){let a;for(;a=o.read();)e++,!(typeof a[0]=="string"&&a[0].startsWith("#"))&&a.length>3&&(r=!0)}),o.on("error",function(a){t({isValid:!1,error:a.message})}),o.on("end",function(){t({isValid:e>0&&r,error:r?void 0:"CSV must have rows with more than 3 columns"})}),o.write(i),o.end()}),"validateCSVFormat");import{parse as wt}from"csv-parse";var ve=c(async(i,t,e)=>(s("[filterTestPlanCSV] Starting CSV filtering..."),s(`[filterTestPlanCSV] testIndex: ${t}, testId: ${e}`),s(`[filterTestPlanCSV] CSV content length: ${i.length}`),new Promise((r,o)=>{let a=[],u,f=0,l=!1,p;s("[filterTestPlanCSV] Initializing CSV parser...");let m=wt({delimiter:"|",skip_empty_lines:!0,trim:!0});m.on("readable",function(){let d;for(;d=m.read();){if(s(`[filterTestPlanCSV] Parsing row: ${JSON.stringify(d)}`),typeof d[0]=="string"&&d[0].startsWith("#")){s(`[filterTestPlanCSV] Found header row: ${JSON.stringify(d)}`),u=d;continue}if(f++,s(`[filterTestPlanCSV] Processing data row ${f}: ${JSON.stringify(d)}`),t&&f===t)s(`[filterTestPlanCSV] Found target row by index ${t}: ${JSON.stringify(d)}`),p=d,l=!0;else if(e&&d.length>0){let w=d[0]?.trim();s(`[filterTestPlanCSV] Checking testId: "${w}" vs target "${e}"`),w===e&&(s(`[filterTestPlanCSV] Found target row by testId "${e}": ${JSON.stringify(d)}`),p=d,l=!0)}}}),m.on("error",function(d){s(`[filterTestPlanCSV] Error parsing CSV: ${d.message}`),o(d)}),m.on("end",function(){if(s("[filterTestPlanCSV] ========== CSV parser 'end' event triggered =========="),s(`[filterTestPlanCSV] foundTest: ${l}`),s(`[filterTestPlanCSV] targetRow exists: ${!!p}`),s(`[filterTestPlanCSV] headerRow exists: ${!!u}`),!l||!p){t?s(`[filterTestPlanCSV] Test index ${t} not found, returning original CSV`):e&&s(`[filterTestPlanCSV] Test ID "${e}" not found, returning original CSV`),s(`[filterTestPlanCSV] Resolving with original CSV (length: ${i.length})`),r(i);return}let d=[];u&&(d.push(u.join("|")),s(`[filterTestPlanCSV] Added header row: ${u.join("|")}`)),p&&(d.push(p.join("|")),s(`[filterTestPlanCSV] Added target row: ${p.join("|")}`));let w=d.join(`
`);t?s(`[filterTestPlanCSV] \u2705 Successfully filtered CSV to test index ${t}`):e&&s(`[filterTestPlanCSV] \u2705 Successfully filtered CSV to test ID "${e}"`),s(`[filterTestPlanCSV] Filtered CSV content (length: ${w.length}):
${w}`),s("[filterTestPlanCSV] ========== Resolving promise with filtered CSV =========="),r(w)}),s(`[filterTestPlanCSV] Writing CSV content to parser (${i.length} characters)...`),m.write(i),s("[filterTestPlanCSV] Calling parser.end()..."),m.end()})),"filterTestPlanCSV");var Ee=c(i=>{let t=bt.join(i,".vibe","test_plan");return yt.readFileSync(t,"utf8")},"readTestPlanRaw"),Ve=c(async i=>{try{let t=Ee(i);if(!(await ae(t)).isValid)return s("[assertTestPlanFile] Returning CRITIQUE - Invalid or empty test plan file"),new y({confidence:1,feedbacks:[{text:"UNACCEPTABLE: Empty or invalid test plan in .vibe/test_plan file. FORBIDDEN to continue without a detailed test plan for the entire project.",structured:{violation:"MANDATORY_QA_PLAN",testId:"N/A",severity:"BLOCKING",penalty:"$2000"},suggestions:[{type:"action",content:"RULE 1: Create comprehensive QA test plan in CSV format in .vibe/test_plan file covering the entire project. NO SHORTCUTS.",severity:"BLOCKING"}]}]});s("[assertTestPlanFile] Test plan file validated successfully");return}catch(t){let e=t.message.toLowerCase();return e.includes("enoent")||e.includes("no such file")?(s("[assertTestPlanFile] Returning CRITIQUE - Missing .vibe/test_plan file"),new y({confidence:1,feedbacks:[{text:"UNACCEPTABLE: Missing .vibe/test_plan file. FORBIDDEN to continue without a detailed test plan for the entire project.",structured:{violation:"MANDATORY_QA_PLAN",testId:"N/A",severity:"BLOCKING",penalty:"$2000"},suggestions:[{type:"action",content:"RULE 1: Create comprehensive QA test plan in .vibe/test_plan file covering the entire project. Step-by-step instructions. NO SHORTCUTS.",severity:"BLOCKING"}]}]})):(s("[assertTestPlanFile] Returning CRITIQUE - Error reading .vibe/test_plan file"),new y({confidence:1,feedbacks:[{text:`UNACCEPTABLE: Error reading .vibe/test_plan file: ${e}! FORBIDDEN to continue without accessible test plan.`,structured:{violation:"QA_PLAN_ACCESS_ERROR",testId:"N/A",severity:"BLOCKING",penalty:"$2000"},suggestions:[{type:"action",content:`Ensure .vibe/test_plan file exists and is readable. Error: ${e}`,severity:"BLOCKING"}]}]}))}},"assertTestPlanFile");import vt from"path";import Et from"fs";var $e=c(i=>{let t=vt.join(i,".vibe","user_flows");try{return Et.readFileSync(t,"utf8")}catch(e){let r=e.message.toLowerCase();if(r.includes("enoent")||r.includes("no such file"))return s("[readUserFlowsRaw] User flows file not found, returning empty content"),"";throw e}},"readUserFlowsRaw"),Ge=c(async i=>{try{let t=$e(i);if(!t.trim()){s("[assertUserFlowsFile] User flows file not found or empty, continuing without user flows");return}if(!(await ae(t)).isValid)return s("[assertUserFlowsFile] Returning CRITIQUE - Invalid user flows file format"),new y({confidence:1,feedbacks:[{text:"Invalid user flows format in .vibe/user_flows file. Please provide valid CSV format or remove the file to proceed without user flows.",structured:{violation:"INVALID_USER_FLOWS_FORMAT",testId:"N/A",severity:"BLOCKING",penalty:"$500"},suggestions:[{type:"action",content:"Fix the CSV format in .vibe/user_flows file or remove the file to proceed without user flows documentation.",severity:"HIGH"}]}]});s("[assertUserFlowsFile] User flows file validated successfully");return}catch(t){let e=t.message.toLowerCase();if(e.includes("enoent")||e.includes("no such file")){s("[assertUserFlowsFile] User flows file not found, continuing without user flows");return}return s("[assertUserFlowsFile] Returning CRITIQUE - Error reading .vibe/user_flows file"),new y({confidence:1,feedbacks:[{text:`Error reading .vibe/user_flows file: ${e}. Please fix the file permissions or remove the file to proceed without user flows.`,structured:{violation:"USER_FLOWS_ACCESS_ERROR",testId:"N/A",severity:"BLOCKING",penalty:"$500"},suggestions:[{type:"action",content:`Fix file permissions for .vibe/user_flows or remove the file to proceed without user flows. Error: ${e}`,severity:"HIGH"}]}]})}},"assertUserFlowsFile");var Pt=c(i=>/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(i.trim()),"isValidUUID"),We=c(i=>{let t=je.join(i,".vibe"),e=je.join(t,"uid");J.existsSync(t)||J.mkdirSync(t,{recursive:!0});let r;try{if(J.existsSync(e)){let o=J.readFileSync(e,"utf8").trim();if(Pt(o))return o;s(`[readAppUID] Invalid UUID found in ${e}, replacing with new one`)}return r=$t(),J.writeFileSync(e,r,"utf8"),s(`[readAppUID] Generated new app UID: ${r}`),r}catch(o){throw s("[readAppUID] Error reading UID:"),s(v(o)),o}},"readAppUID"),qe=c(async i=>At(i.projectFolderPath)??Ct(i)??await xt(i)??await Ve(i.projectFolderPath)??await Ge(i.projectFolderPath)??await _t(i),"assertEvaluationRequest"),At=c(i=>{if(!i)return s("[assertEvaluationRequest] Returning CRITIQUE - Missing project folder path"),new y({confidence:1,feedbacks:[{text:"UNACCEPTABLE: Missing projectFolderPath. FORBIDDEN to proceed without project path.",structured:{violation:"MANDATORY_PROJECT_PATH",testId:"N/A",severity:"BLOCKING",penalty:"$1000"},suggestions:[{type:"action",content:`RULE 1: Provide the absolute path to the project folder (e.g., '/path/to/project').
                                NO EXCEPTIONS.`,severity:"HIGH"}]}]})},"assertProjectFolderPath"),Ct=c(i=>{let{projectRunCommand:t,projectRunUrl:e}=i;if(!e&&!t)return s("[assertEvaluationRequest] Returning CRITIQUE - Missing project run command"),new y({confidence:1,feedbacks:[{text:"UNACCEPTABLE: Missing projectRunCommand. FORBIDDEN to proceed without run command or running server address.",structured:{violation:"MANDATORY_PROJECT_RUN_COMMAND",testId:"N/A",severity:"BLOCKING",penalty:"$1000"},suggestions:[{type:"action",content:`RULE 2: Either provide the run command to start the project locally (e.g., 'yarn dev' or 'npm start') OR provide the projectRunUrl of an already running server.
                            NO EXCEPTIONS.`,severity:"HIGH"}]}]})},"assertProjectRunCommand"),xt=c(async i=>{let{projectRunUrl:t}=i;if(t){if(!/^(https?|file):\/\/\S*$/.test(t))return s("[assertEvaluationRequest] Returning CRITIQUE - Invalid project run address format"),new y({confidence:1,feedbacks:[{text:`UNACCEPTABLE: Invalid projectRunUrl format '${t}'. Must be a valid HTTP/HTTPS/FILE URL.`,structured:{violation:"INVALID_PROJECT_RUN_ADDRESS",testId:"N/A",severity:"BLOCKING",penalty:"$500"},suggestions:[{type:"action",content:"Provide a valid URL format for projectRunUrl (e.g., 'http://localhost:3000', 'https://localhost:8080', 'file:///path/to/file.html').",severity:"HIGH"}]}]});try{await ne(t)}catch(r){return s("validateWebappUrl Error:"),s(v(r)),new y({confidence:1,feedbacks:[{text:`UNACCEPTABLE: Unaccessible projectRunUrl '${t}'.`,structured:{violation:"UNACCESSIBLE_PROJECT_RUN_ADDRESS",testId:"N/A",severity:"BLOCKING",penalty:"$500"},suggestions:[{type:"action",content:"Provide an accessible URL for projectRunUrl",severity:"HIGH"}]}]})}}},"assertProjectRunUrl"),_t=c(async i=>{let{targetTests:t}=i;if(t){if(!Array.isArray(t))return s("[assertTargetTests] Returning CRITIQUE - targetTests must be an array"),new y({confidence:1,feedbacks:[{text:"UNACCEPTABLE: targetTests must be an array. FORBIDDEN to proceed with invalid format.",structured:{violation:"INVALID_TARGET_TESTS_FORMAT",testId:"N/A",severity:"BLOCKING",penalty:"$500"},suggestions:[{type:"action",content:"Provide targetTests as an array of objects with testId and context fields.",severity:"HIGH"}]}]});for(let e=0;e<t.length;e++){let r=t[e];if(!r||typeof r!="object")return s(`[assertTargetTests] Returning CRITIQUE - targetTests[${e}] must be an object`),new y({confidence:1,feedbacks:[{text:`UNACCEPTABLE: targetTests[${e}] must be an object. FORBIDDEN to proceed with invalid format.`,structured:{violation:"INVALID_TARGET_TEST_ITEM",testId:"N/A",severity:"BLOCKING",penalty:"$500"},suggestions:[{type:"action",content:"Each targetTest item must be an object with testId and context fields.",severity:"HIGH"}]}]});if(!r.testId||typeof r.testId!="string")return s(`[assertTargetTests] Returning CRITIQUE - targetTests[${e}].testId must be a string`),new y({confidence:1,feedbacks:[{text:`UNACCEPTABLE: targetTests[${e}].testId must be a string. FORBIDDEN to proceed without valid testId.`,structured:{violation:"MISSING_TARGET_TEST_ID",testId:"N/A",severity:"BLOCKING",penalty:"$500"},suggestions:[{type:"action",content:"Provide a valid testId string that matches a testId in test_plan.",severity:"HIGH"}]}]});if(!r.context||typeof r.context!="string")return s(`[assertTargetTests] Returning CRITIQUE - targetTests[${e}].context must be a string`),new y({confidence:1,feedbacks:[{text:`UNACCEPTABLE: targetTests[${e}].context must be a string. FORBIDDEN to proceed without context.`,structured:{violation:"MISSING_TARGET_TEST_CONTEXT",testId:"N/A",severity:"BLOCKING",penalty:"$500"},suggestions:[{type:"action",content:"Provide a context string explaining why this test is being re-run.",severity:"HIGH"}]}]})}s(`[assertTargetTests] Validated ${t.length} target tests structure successfully`)}},"assertTargetTests"),He=c(i=>{let t=i.filter(({result:r,error:o})=>o||r?.decision!=="PASS");if(t.length){let r=t.map(({result:u,error:f})=>u||f?.toEvaluationResult()),o=r.flatMap(u=>u.feedbacks||[]).filter(u=>!!u?.text?.trim()||!!u.structured?.violation);return{decision:"CRITIQUE",confidence:Math.max(...r.map(u=>u.confidence)),feedbacks:o,metadata:{parallelExecutions:i.length}}}let e=i.flatMap(({result:r})=>r.feedbacks||[]).filter(r=>!!r?.text?.trim());return{decision:"PASS",confidence:i.length>0?Math.min(...i.map(({result:r})=>r.confidence)):0,feedbacks:e,metadata:{parallelExecutions:i.length}}},"aggregateTestResults");function Je(i=6){try{let t=St().length,e=Math.round(Rt()/1024/1024),r=Math.round(Tt()/1024/1024),o=te(),a=1/0;try{if(o!=="windows"){let d=It("ulimit -n",{encoding:"utf8",timeout:1e3}).trim(),w=parseInt(d);!isNaN(w)&&w>0&&(a=Math.floor(w/60),s(`[calculateOptimalParallelInstances] File descriptor limit: ${w}, allowing ~${a} instances`))}}catch(d){s(`[calculateOptimalParallelInstances] Could not check file descriptor limits: ${d}`)}let u=150,f;if(r<2048){let d;e<=8192?d=800:e<=16384?d=1200:e<=32768?d=1800:d=2400,f=Math.max(1,Math.min(Math.floor(d/u),10)),s(`[calculateOptimalParallelInstances] Memory pressure detected (${r}MB free), using tiered allocation: ${d}MB available for ${e}MB system`)}else{let d=Math.min(2048,Math.max(1024,r*.2)),w=Math.max(0,r-d);f=Math.floor(w/u)}let l=Math.max(1,Math.min(Math.floor(t*2),14)),p;switch(o){case"macos":p=Math.min(t*2+4,16);break;case"linux":p=Math.min(t*2+6,18);break;case"windows":p=Math.min(t*2,12);break;default:p=Math.min(t*2,12)}let m=Math.max(1,Math.min(f,l,p,a,16));return s(`[calculateOptimalParallelInstances] System info: ${t} CPUs, ${e.toLocaleString()}MB total RAM, ${r.toLocaleString()}MB free RAM, OS: ${o}`),s(`[calculateOptimalParallelInstances] Memory calculation: Per instance ${u}MB, Memory-based limit: ${f}`),s(`[calculateOptimalParallelInstances] Calculated limits - Memory: ${f}, CPU: ${l}, Platform: ${p}, FD: ${a===1/0?"unlimited":a}`),s(`[calculateOptimalParallelInstances] Selected optimal instances: ${m}`),m}catch(t){return s(`[calculateOptimalParallelInstances] Error calculating optimal instances: ${t}`),s(`[calculateOptimalParallelInstances] Falling back to default: ${i}`),i}}c(Je,"calculateOptimalParallelInstances");var Se=c((i,t,e)=>(s(`[toDashboardSessionUpdate] session: ${i.session_uid}, currentStep: ${t}, test_steps: ${JSON.stringify(i.test_steps)}`),{sessionUid:i.session_uid,currentStep:t,totalSteps:i.test_steps.length,taskName:i.test_name,taskDescription:i.test_description,testId:i.test_id,stepDescriptions:i.test_steps.map((r,o)=>(s(`[buildDashboardSession] Step ${o}: ${JSON.stringify(r)}`),s(`[buildDashboardSession] Step ${o} action type: ${typeof r.action}, value: ${JSON.stringify(r.action)}`),typeof r.action=="string"?r.action:(s(`[buildDashboardSession] WARNING: Step ${o} action is not a string, converting: ${JSON.stringify(r.action)}`),String(r.action||"Unknown action")))),lastUpdate:Date.now(),screenshot:e}),"toDashboardSessionUpdate"),Ke=c(i=>{for(let t=0;t<i.length;t++){let e=i[t];if(!e.session_uid)throw new Error(`No session uid found in session ${t}`);if(!e.test_id)throw new Error(`No test ID found in session ${e.session_uid}`);if(!e.test_name&&!e.test_description)throw new Error(`No test name nor description found in session ${e.session_uid}`);if(!e.test_steps?.filter(r=>(r&&typeof r.action!="string"&&s(`[assertQASessions] Invalid action type in session ${e.session_uid}: action=${JSON.stringify(r.action)}, step=${JSON.stringify(r)}`),r?.action&&typeof r.action=="string"&&r.action.trim().length>0)).length)throw new Error(`No valid test steps found in session ${e.session_uid}`)}},"assertQASessions");import*as z from"path";import*as Te from"fs";import{fileURLToPath as Dt}from"url";import Nt from"puppeteer";var Xe=c((i,t)=>{s(`[fromQASessionToDashboardSession] session: ${i.session_uid}, test_steps: ${JSON.stringify(i.test_steps)}`);let e=i.test_steps.map((r,o)=>(s(`[fromQASessionToDashboardSession] Step ${o}: ${JSON.stringify(r)}`),s(`[fromQASessionToDashboardSession] Step ${o} action type: ${typeof r.action}, value: ${JSON.stringify(r.action)}`),typeof r.action=="string"?r.action:(s(`[fromQASessionToDashboardSession] WARNING: Step ${o} action is not a string, converting: ${JSON.stringify(r.action)}`),String(r.action||"Unknown action"))));return{sessionUid:i.session_uid,position:t,status:"pending",taskName:i.test_name,taskDescription:i.test_description,testId:i.test_id,currentStep:0,totalSteps:i.test_steps.length,stepDescriptions:e,lastUpdate:Date.now()}},"fromQASessionToDashboardSession");var Ot=Dt(import.meta.url),Ze=z.dirname(Ot),U,E,le,V={maxRetries:3,retryDelay:1e3,recoveryDelay:500},et=c(i=>{let t=i;for(;t!==z.dirname(t);){let e=z.join(t,"package.json");if(Te.existsSync(e))return t;t=z.dirname(t)}return process.cwd()},"findProjectRoot");async function kt(){try{if(s("\u{1F504} Attempting to recover dashboard page connection..."),!U||!U.isConnected())return s("\u274C Dashboard browser is disconnected, cannot recover"),!1;let t=(await U.pages()).find(a=>!a.isClosed());if(t)return E=t,s("\u2705 Recovered dashboard page connection"),!0;let e=et(Ze),o=`file://${z.join(e,"src/dashboard/index.html")}`;return E=await U.newPage(),await E.goto(o),E.on("console",async a=>{let u=a.text();if((u.includes("EXTERNAL_URL_REQUEST")||u.includes("Opening external app dashboard"))&&s(`[Dashboard Console] ${u}`),u.startsWith("EXTERNAL_URL_REQUEST:")){let f=u.replace("EXTERNAL_URL_REQUEST:","").trim();s(`[Dashboard] Opening external URL in system browser: ${f}`);let{default:l}=await import("open");try{await l(f),s(`[Dashboard] Successfully opened ${f} in system browser`)}catch(p){s(`[Dashboard] Failed to open ${f}: ${p.message}`)}}}),await E.evaluate(()=>{window.addEventListener("openExternalUrl",a=>{console.log("EXTERNAL_URL_REQUEST:",a.detail.url)})}),await new Promise(a=>setTimeout(a,V.recoveryDelay)),s(`\u2705 Created new dashboard page and navigated to ${o}`),!0}catch(i){return s(`\u274C Failed to recover dashboard page: ${i}`),!1}}c(kt,"recoverDashboardPage");async function K(i,t,e){let r=null;for(let o=1;o<=V.maxRetries;o++)try{return await i()}catch(a){r=a;let u=e?` for session ${e}`:"";if(s(`\u26A0\uFE0F Dashboard error in ${t}${u} (attempt ${o}/${V.maxRetries}): ${r.message}`),o===V.maxRetries){s(`\u274C Max retries reached for ${t}${u}`);break}if(!await kt()){s(`\u274C Failed to recover dashboard page, stopping retries for ${t}${u}`);break}await new Promise(l=>setTimeout(l,V.retryDelay)),s(`\u{1F504} Retrying ${t}${u} (attempt ${o+1}/${V.maxRetries})`)}if(r){let o=e?` for session ${e}`:"";s(`\u274C Failed to execute ${t}${o} after ${V.maxRetries} attempts: ${r.message}`)}return null}c(K,"executeWithRetry");var tt=c(async(i,t,e,r)=>{try{s(`\u{1F680} Opening Puppeteer dashboard with ${i.length} sessions`);let o=et(Ze),a=z.join(o,"src/dashboard/index.html");if(!Te.existsSync(a))throw new Error(`Dashboard HTML file not found at: ${a}`);if(U&&E)return s("\u{1F504} Reusing existing dashboard browser instance"),await Ye(t,i,e,r);let u=`file://${a}`;return U=await Nt.launch({headless:!1,defaultViewport:null,protocolTimeout:0,args:["--no-sandbox","--disable-setuid-sandbox","--start-maximized","--app="+u,"--disable-web-security","--disable-features=VizDisplayCompositor","--disable-background-timer-throttling","--disable-renderer-backgrounding","--disable-backgrounding-occluded-windows","--disable-infobars","--disable-session-crashed-bubble","--disable-translate","--no-first-run","--disable-default-apps"]}),le=B.register(U,"Dashboard-Browser"),E=(await U.pages())[0],E.on("console",async l=>{let p=l.text();if((p.includes("EXTERNAL_URL_REQUEST")||p.includes("Opening external app dashboard"))&&s(`[Dashboard Console] ${p}`),p.startsWith("EXTERNAL_URL_REQUEST:")){let m=p.replace("EXTERNAL_URL_REQUEST:","").trim();s(`[Dashboard] Opening external URL in system browser: ${m}`);let{default:d}=await import("open");try{await d(m),s(`[Dashboard] Successfully opened ${m} in system browser`)}catch(w){s(`[Dashboard] Failed to open ${m}: ${w.message}`)}}}),await E.evaluate(()=>{window.addEventListener("openExternalUrl",l=>{console.log("EXTERNAL_URL_REQUEST:",l.detail.url)})}),U.on("disconnected",()=>{s("\u{1F534} Dashboard browser disconnected"),le&&(B.unregister(le),le=void 0),U=void 0,E=void 0}),s(`\u2705 Dashboard opened in maximized app mode: file://${a}`),await Ye(t,i,e,r)}catch(o){s(`\u274C Failed to open dashboard: ${o}`);return}},"openRealtimeBrowser");async function Ye(i,t,e,r){if(s(`[initializeDashboardData] manual filter: ${i}, num of total sessions: ${t.length}`),!E)return;let o=i?await Ut(t):void 0;if(i&&!o?.length)throw new Error("Manual filter enabled, but no tests were selected");let a=o?.length?t.filter(l=>o.includes(l.test_id)):t;s(`[initializeDashboardData] num of filtered sessions: ${a.length}`);let u=a.map((l,p)=>Xe(l,p));return await K(async()=>{await E.evaluate((l,p,m)=>{window.addEventListener("openExternalUrl",d=>{console.log("EXTERNAL_URL_REQUEST:",d.detail.url)}),window.dispatchEvent(new CustomEvent("dashboardInit",{detail:{sessions:l,appUid:p,apiUrl:m}}))},u,e,r)},"initializeDashboardData")!==null&&s(`\u{1F4CA} Dashboard initialized with ${u.length} sessions`),o}c(Ye,"initializeDashboardData");async function Ut(i){if(E)try{s(`\u{1F3AF} Showing test filtering UI for ${i.length} tests`);let t=i.map(r=>({id:r.test_id,title:r.test_name||r.test_description})),e=await E.evaluate(`
            (function(tests) {
                return new Promise(function(resolve) {
                    console.log('\u{1F3AF} [PAGE] Starting filtering UI with ' + tests.length + ' tests');

                    // Dispatch event to show filtering UI
                    window.dispatchEvent(
                        new CustomEvent("showTestFilter", {
                            detail: { tests: tests },
                        })
                    );

                    console.log('\u23F3 [PAGE] Waiting for user selection...');

                    // Wait for user to make selection
                    var handleFilterComplete = function(event) {
                        var customEvent = event;
                        console.log(
                            '\u{1F389} [PAGE] Filter complete event received with IDs:',
                            customEvent.detail.selectedTestIds
                        );
                        window.removeEventListener("filterComplete", handleFilterComplete);
                        resolve(customEvent.detail.selectedTestIds);
                    };
                    window.addEventListener("filterComplete", handleFilterComplete);
                    console.log(
                        '\u{1F442} [PAGE] Event listener set up, waiting for filterComplete event'
                    );
                });
            })(${JSON.stringify(t)})
                `);return s(`\u2705 User selected ${e?.length||0} ${se(e?.length||0,"test")}: ${e?.join(", ")||"none"}`),e}catch(t){s(`\u274C Failed to show test filtering UI: ${t}`);return}}c(Ut,"showTestFilteringUI");var st=c(async i=>{if(!E)return;await K(async()=>{await E.evaluate(e=>{window.dispatchEvent(new CustomEvent("dashboardRunning",{detail:{sessionUid:e}}))},i)},"markDashboardSessionRunning",i)!==null&&s(`\u{1F504} Dashboard session ${i} marked as running`)},"markDashboardSessionRunning"),Re=c(async i=>{if(!E){s(`\u26A0\uFE0F Dashboard not available for session ${i.sessionUid}`);return}await K(async()=>{await E.evaluate(e=>{let r={sessionUid:e.sessionUid,status:"running",currentStep:e.currentStep,totalSteps:e.totalSteps,taskName:e.taskName,taskDescription:e.taskDescription,stepDescriptions:e.stepDescriptions,lastUpdate:Date.now(),testId:e.testId};window.dispatchEvent(new CustomEvent("dashboardUpdate",{detail:{sessionUid:e.sessionUid,data:r,screenshot:e.screenshot}}))},i)},"updateDashboardSession",i.sessionUid)!==null&&s(`\u{1F4C8} Dashboard updated for session ${i.sessionUid}`)},"updateDashboardSession"),Ie=c(async(i,t)=>{if(!E)return;await K(async()=>{await E.evaluate((r,o)=>{window.dispatchEvent(new CustomEvent("dashboardComplete",{detail:{sessionUid:r,result:o}}))},i,t)},"markDashboardSessionComplete",i)!==null&&s(`\u{1F3C1} Dashboard session ${i} marked as ${t.decision} (kept visible)`)},"markDashboardSessionComplete"),Pe=c(async i=>{if(!E)return;await K(async()=>{await E.evaluate(e=>{window.dispatchEvent(new CustomEvent("dashboardAborted",{detail:{sessionUid:e}}))},i)},"markDashboardSessionAborted",i)!==null&&s(`\u{1F6D1} Dashboard session ${i} marked as aborted`)},"markDashboardSessionAborted");import Lt from"p-limit";var ce=class i{static{c(this,"EvaluatorOptimizer")}static evalCalls=0;tool=new oe;args;constructor(t){this.args=t}async evaluate(t){let e=`evaluate-${++i.evalCalls}-${Date.now()}`;n.start("evaluate",{uid:e});try{s("=== [EvaluatorOptimizer] evaluate called: ===");let r=JSON.stringify(t,null,2);s(r),n.start("evaluate-request-validation",{uid:e});let o=await qe(t);if(n.end("evaluate-request-validation",{uid:e,hasError:!!o}),o)throw n.end("evaluate",{uid:e,result:"assertion-error"}),s("=== [EvaluatorOptimizer] assertion error: ==="),s(JSON.stringify(o,null,2)),o;s("=== [EvaluatorOptimizer] Starting parallel QA automation workflow ==="),$.evaluateStarted();let a=await this.executeQAWorkflow(t),u=a.decision==="PASS";return n.end("evaluate",{uid:e,result:a.decision}),{...a,systemNotifications:a.systemNotifications||[{type:u?"success":"warning",message:u?`${Z} has completed the evaluation. All passed!`:`${Z} has found ${a.feedbacks.length} ${se(a.feedbacks.length,"issue")}. I'm on it!`,priority:"high",actionRequired:!u}]}}catch(r){throw n.end("evaluate",{uid:e,result:"error"}),s("=== [EvaluatorOptimizer] Error during evaluation: ==="),s(v(r)),q(r,new y({confidence:.1,feedbacks:[{text:"SYSTEM ERROR: Evaluator offline. FORBIDDEN to proceed without validation.",structured:{violation:`EVALUATOR_FAILURE: ${r.message}`,testId:"N/A",penalty:"$500"}}],metadata:{error:r.message},systemNotifications:[{type:"error",message:`${Z} is offline. Please contact support for assistance.`,priority:"high",actionRequired:!0}]})),r}}async executeQAWorkflow(t){let e=`workflow-${i.evalCalls}-${Date.now()}`;n.start("executeQAWorkflow",{uid:e});let{projectFolderPath:r,projectRunCommand:o,projectRunUrl:a,appDescription:u,targetTests:f,userPrompt:l}=t,{start:p,only:m,onlyIndex:d,onlyTestId:w,ignoreIndices:b,ignoreStrings:h,"fail-fast":C,"manual-filter":P}=this.args,x,S;try{if(n.start("webapp-setup",{uid:e}),a)try{await ne(a),x=a,s(`[EvaluatorOptimizer] Using provided webapp URL: ${a}`)}catch(g){n.end("webapp-setup",{uid:e,result:"url-validation-failed"}),n.end("executeQAWorkflow",{uid:e,result:"url-validation-failed"}),s("[EvaluatorOptimizer] Failed to validate provided webapp URL"),s(v(g));let R=a?.startsWith("file:///");throw new y({confidence:.1,feedbacks:[{text:R?`Cannot access the specified file at ${a}. Please ensure the file exists and is accessible.`:`Cannot connect to the specified running server at ${a}. Please ensure the server is running and accessible.`,structured:{violation:`${R?"FILE_NOT_FOUND":"RUNNING_SERVER_UNAVAILABLE"}: ${g?.message||"Unknown error"}`,testId:"N/A",severity:"BLOCKING"},suggestions:[{type:"action",content:R?`Verify that the file exists at the specified path: ${a}`:`Verify that the development server is running at ${a} and accessible.`,severity:"HIGH"}]}]})}else if(o)try{S=new H,x=(await S.startWebapp(r,o)).url,s(`[EvaluatorOptimizer] Started webapp at "${x}"`)}catch(g){throw n.end("webapp-setup",{uid:e,result:"webapp-start-failed"}),n.end("executeQAWorkflow",{uid:e,result:"webapp-start-failed"}),s("[EvaluatorOptimizer] Failed to start webapp"),s(v(g)),new y({confidence:.9,feedbacks:[{text:`Failed to start webapp: ${g.message}`,structured:{violation:`WEBAPP_START_FAILURE: ${g.message}`,testId:"N/A",severity:"BLOCKING"},suggestions:[{type:"action",content:"Check the project run command and ensure all dependencies are installed.",severity:"HIGH"}]}]})}if(!x)throw new Error("No webapp URL available - this should not happen");n.end("webapp-setup",{uid:e,webappUrl:x});let D=r.split("/").filter(Boolean).pop()||"unknown-app";s(`[EvaluatorOptimizer] Starting QA workflow for "${D}"`),n.start("sessions-preparation",{uid:e});let I=We(r),Q=Ee(r);if(d||w){s("[EvaluatorOptimizer] ========== --only parameter detected =========="),s(`[EvaluatorOptimizer] onlyIndex: ${d}`),s(`[EvaluatorOptimizer] onlyTestId: ${w}`),s(`[EvaluatorOptimizer] Original test plan length: ${Q.length} characters`),s(`[EvaluatorOptimizer] Original test plan content (first 200 chars):
${Q.substring(0,200)}...`);try{s("[EvaluatorOptimizer] Calling filterTestPlanCSV...");let g=await ve(Q,d,w);s("[EvaluatorOptimizer] filterTestPlanCSV returned successfully"),s(`[EvaluatorOptimizer] Filtered test plan length: ${g.length} characters`),s(`[EvaluatorOptimizer] Filtered test plan content:
${g}`),g.trim()===""?s("[EvaluatorOptimizer] WARNING: Filtered test plan is empty! Using original plan."):(Q=g,s("[EvaluatorOptimizer] Successfully applied filtered test plan"))}catch(g){s(`[EvaluatorOptimizer] ERROR filtering test plan CSV: ${v(g)}`),s(`[EvaluatorOptimizer] Error stack: ${g instanceof Error?g.stack:"No stack trace"}`),s("[EvaluatorOptimizer] Continuing with original test plan due to filtering error")}s("[EvaluatorOptimizer] ========== End --only parameter processing ==========")}else s(`[EvaluatorOptimizer] No --only parameter detected (onlyIndex: ${d}, onlyTestId: ${w})`);let nt=$e(r),{sessions:T,runId:N}=await new M(this.args["api-url"]).asyncPrepWithStatePolling({app_uid:I,app_name:D,app_description:u,context:{timestamp:Date.now(),locale:Intl.DateTimeFormat().resolvedOptions().locale||"en_US"},initial_plan:Q,user_flows:nt,requirements:l,target_tests:JSON.stringify(f??[]),only:d||w?void 0:typeof m=="number"?m:void 0,start:p,ignore_indices:b,ignore_test_ids:h,thinking_budget:this.args["thinking-budget"]});if(Ke(T),s(`[EvaluatorOptimizer] Received ${T.length} QA sessions from /async_prep endpoint (after server-side filtering) for runId: ${N}`),T.length===0)throw n.end("sessions-preparation",{uid:e,result:"no-sessions-available"}),n.end("executeQAWorkflow",{uid:e,result:"no-sessions-available"}),new y({confidence:1,feedbacks:[{text:"No sessions available to run. This may be due to filtering parameters or no test plan available.",structured:{violation:"NO_SESSIONS_AVAILABLE",testId:"N/A",severity:"BLOCKING"},suggestions:[{type:"action",content:"Review your filtering parameters and ensure test plan is available.",severity:"HIGH"}]}],metadata:{filteredSessionCount:T.length,hasOnlyFilter:m!==void 0,hasStartFilter:p!==void 0,hasIgnoreFilters:(b?.length||0)+(h?.length||0)>0}});if(n.end("sessions-preparation",{uid:e,runId:N,sessionCount:T.length}),s(`[EvaluatorOptimizer] Prepared ${T.length} QA sessions:
${T.map(g=>g.session_uid).join(`
`)}`),Ue)s("[EvaluatorOptimizer] Skipping dashboard opening in test environment");else{n.start("launching-dashboard",{uid:e,runId:N,sessionCount:T.length});try{let g=await tt(T,P,I,this.args["api-url"]);if(g?.length){let R=T.filter(A=>g.includes(A.test_id));s(`[EvaluatorOptimizer] Manual filter applied: ${R.length}/${T.length} sessions selected`),T.splice(0,T.length,...R)}n.end("launching-dashboard",{uid:e,runId:N,sessionCount:T.length})}catch(g){n.end("launching-dashboard",{uid:e,runId:N,sessionCount:T.length,error:g.message}),s("[EvaluatorOptimizer] Failed to open realtime browser"),s(v(g))}}let Ae=this.args.parallel??Je();s(`[EvaluatorOptimizer] Executing ${Ae} parallel instances ${this.args.parallel?"(user-specified)":"(auto-calculated)"}`);let Ce=Lt(Ae),X=T.map((g,R)=>{let A=new AbortController,L=new M(this.args["api-url"],A.signal);s(`[EvaluatorOptimizer] Created executor for session ${g.session_uid} (testId: ${g.test_id})`);let _={},_e=c(()=>{_.executorStartTime=Date.now(),_.testTimeoutMs=this.args["test-timeout"]*1e3,_.timeoutId=setTimeout(()=>{let O=Date.now()-_.executorStartTime;s(`[EvaluatorOptimizer ${g.session_uid}] Test timeout after ${O}ms (limit: ${_.testTimeoutMs}ms)`),De.abort()},_.testTimeoutMs)},"setExecutorTimeout"),W=c(()=>{typeof _.timeoutId<"u"&&(clearTimeout(_.timeoutId),delete _.timeoutId)},"clearExecutorTimeout"),at=c(()=>{s(`[EvaluatorOptimizer ${g.session_uid}] Resetting test timeout`),W(),_e()},"resetExecutorTimeout"),De={session:g,execute:c(()=>Ce(async()=>{s(`[EvaluatorOptimizer] Starting task ${R+1}/${T.length}: ${g.session_uid} (testId: ${g.test_id})`),_e(),st(g.session_uid);try{let O=await this.#e(g,x,L,A,at,r,N);return W(),O}catch(O){if(W(),await Ie(g.session_uid,{decision:"CRITIQUE",feedbacks:[{structured:{error:O.message}}]}),O instanceof y)return{result:O.toEvaluationResult()};let Ne=Date.now()-_.executorStartTime;if(A.signal.aborted&&Ne>=_.testTimeoutMs)return{result:new y({confidence:1,feedbacks:[{text:`Test execution timed out after ${this.args["test-timeout"]} seconds. This is considered a stale test.`,structured:{violation:"STALE_TEST",severity:"HIGH",testId:g.test_id},suggestions:[{type:"action",content:"Review test complexity or increase timeout limit with --test-timeout parameter",severity:"HIGH"}]}],metadata:{staleTest:!0,executionTimeMs:Ne,timeoutLimitMs:_.testTimeoutMs}}).toEvaluationResult()};throw O}finally{W(),$.incrementCompletedTests()}}),"execute"),abort:c(()=>{W(),s(`[EvaluatorOptimizer ${g.session_uid}] Aborting session`),L.abort(g.session_uid).catch(O=>{s(`[EvaluatorOptimizer ${g.session_uid}] Failed to call abort API: ${O.message}`)}).finally(()=>{A.abort(),Pe(g.session_uid)})},"abort")};return De});$.setTotalTests(X.length),$.testsExecutionStarted(),n.start("tests-execution",{uid:e,runId:N,sessionCount:T.length});let Y,xe=X.map(g=>{let R=g.session.session_uid,A=g.session.test_id;return g.execute().then(L=>(s(`[EvaluatorOptimizer ${R}] Test ${A} completed with decision: ${L.result.decision}, error: ${L.error??"None"}`),L)).catch(L=>{throw s(`[EvaluatorOptimizer ${R}] Test ${A} failed with error: ${v(L)}`),L})});C?Y=await ke(xe,async(g,{result:R,error:A})=>!A&&R.decision==="PASS",async g=>{Ce.clearQueue(),g.forEach(R=>{X[R].abort()})}):Y=(await Promise.allSettled(xe)).map((g,R)=>{switch(g.status){case"fulfilled":return g.value;case"rejected":{let A=y.fromError(g.reason,X[R].session.test_id);return{result:A.toEvaluationResult(),error:A}}}}),n.end("tests-execution",{uid:e,runId:N,resultCount:Y.length}),n.start("result-aggregation",{uid:e,runId:N});let pe=He(Y);return n.end("result-aggregation",{uid:e,runId:N,decision:pe.decision}),n.end("executeQAWorkflow",{uid:e,result:pe.decision}),pe}catch(D){n.end("executeQAWorkflow",{uid:e,error:D.message}),s("[EvaluatorOptimizer] Error in QA workflow execution:"),s(v(D));let I=D?.message||"Unknown error";throw q(D,new y({confidence:.1,feedbacks:[{text:`QA automation failed: ${I}`,structured:{violation:`QA_WORKFLOW_FAILURE: ${I}`,testId:"N/A",severity:"BLOCKING"},suggestions:[{type:"action",content:"Check the project setup and ensure all dependencies are available.",severity:"HIGH"}]}]})),D}finally{await S?.stopWebapp()}}async#e(t,e,r,o,a,u,f){let l=t.session_uid,p=t.test_id;n.start("qa-session",{uid:l,testId:p});let m=new ie(t,e,!this.args["no-headless"]);try{await m.launchBrowser(),await new Promise(h=>setTimeout(h,2e3));let d=await m.getViewportBounds(),w=await m.takeScreenshot(d);await Re(Se(t,0,w));let b=await this.#s(t,m,r,o,a,u,f);return n.end("qa-session",{uid:l,testId:p,decision:b.decision}),{result:b}}catch(d){if(o.signal.aborted)return n.end("qa-session",{uid:l,testId:p,result:"aborted"}),s(`[EvaluatorOptimizer ${l}] execution aborted`),await Pe(l),{result:new y({confidence:0,feedbacks:[{text:"QA session aborted",structured:{violation:"QA_AUTOMATION_ABORTED",testId:p}}],metadata:{aborted:!0}}).toEvaluationResult()};n.end("qa-session",{uid:l,testId:p,result:"error"}),s(`[EvaluatorOptimizer ${l}] execution error (testId: ${p})`),s(v(d));let w=d?.message||"Unknown error";throw q(d,new y({confidence:.1,feedbacks:[{text:`QA automation failed: ${w}`,structured:{violation:`QA_SESSION_FAILURE: ${w}`,testId:p,severity:"BLOCKING"},suggestions:[{type:"action",content:"Check the project setup and ensure all dependencies are available.",severity:"HIGH"}]}]})),d}finally{await m.cleanup()}}async#s(t,e,r,o,a,u,f){let l=t.session_uid,p=t.test_id;n.start("qa-loop",{uid:l,testId:p});let m=!0,d,w,b;for(;m;){if(o.signal.aborted)throw s(`[executeQALoop ${l}] Loop aborted by abort controller`),new Error("QA loop aborted");let h=d?.curr_step??0;try{n.start("qa-step",{uid:l,testId:p,step:`${h}`});let C=await e.extractDOM(),P=await e.getViewportBounds(),x=await e.getDevicePixelRatio();await e.freezePage();let S,D;try{let I=await e.takeScreenshot();try{Le(u,f,l,h,I)}catch{}D=await e.takeScreenshot(P);let Q={x0:P.x0*x,y0:P.y0*x,x1:P.x1*x,y1:P.y1*x};S=await r.step(t.session_uid,{dom:C,screenshot:I,viewportBounds:Q,...w&&{error:w},...b&&{last_action_uid:b}})}finally{await e.unfreezePage()}if(b?s(`[executeQALoop ${l}] Sending last_action_uid: ${b}`):s(`[executeQALoop ${l}] No last_action_uid to send (first request or no previous action_uid)`),w=void 0,b=S.action_uid,S.action_uid?s(`[executeQALoop ${l}] Received action_uid: ${S.action_uid}`):s(`[executeQALoop ${l}] No action_uid received`),s(`[executeQALoop ${l}] Received step response  ${JSON.stringify({action:S.action,currStep:h,action_uid:S.action_uid})}`),S.action==="FINISH"&&s(`[executeQALoop ${l}] FINISH response - Full stepResponse: ${JSON.stringify(S,null,2)}`),S.session_status&&S.action!=="FINISH"&&(d=S.session_status,await Re(Se(t,h,D))),m=await this.#r(S,e,a),n.end("qa-step",{uid:l,testId:p,step:`${h}`,action:S.action,shouldContinue:m}),!m){let I=JSON.parse(S.result);return n.end("qa-loop",{uid:l,testId:p,step:`${h}`,decision:I.decision}),s(`[executeQALoop ${l}] FINISH action - Parsed result: ${JSON.stringify(I,null,2)}`),await Ie(l,{decision:I.decision,confidence:I.confidence,feedbacks:I.feedbacks,metadata:I.metadata}),I}}catch(C){let P=C.message;if(this.#t(P)){w=P,s(`[executeQALoop ${l}] Selector error at step ${h}, will propagate to next step: ${P}`),n.end("qa-step",{uid:l,testId:p,step:`${h}`,result:"selector-error-propagated"});continue}else n.end("qa-step",{uid:l,testId:p,step:`${h}`,result:"error"}),n.end("qa-loop",{uid:l,testId:p,step:`${h}`,result:"error"}),s(`[EvaluatorOptimizer ${l}] Error in QA loop, Task ${p}, Step ${h}`),s(v(C)),q(C,new y({confidence:.1,feedbacks:[{text:`QA automation failed at task ${p}, step ${h}:
${P}`,structured:{violation:`QA_STEP_FAILURE: ${P}`,testId:`${p}`,step:`${h}`}}],metadata:{failedStep:h}}))}}throw new Error("QA automation loop ended without FINISH action")}#t(t){return t.includes("Failed to focus on element with selector")||t.includes("Failed to click on element with selector")||t.includes("Cannot find element with selector")||t.includes("data-qa-id")}async#r(t,e,r){switch(t.action){case"RESET":return t.is_replay&&(s("[processQAAction] RESET with is_replay=true: Resetting test timeout"),r()),await e.resetPageState(),t.focus&&(s("[processQAAction] RESET: Focusing on element before actions"),await e.focusElement(t.focus)),t.native_click&&(s("[processQAAction] RESET: Clicking on element before actions"),await e.clickElement(t.native_click)),t.keystroke!==void 0&&(s("[processQAAction] RESET: Pressing key before script injection"),await e.pressKey(t.keystroke)),t.script&&await e.executeScript(t.script),!0;case"INJECT":return t.focus&&(s("[processQAAction] INJECT: Focusing on element before actions"),await e.focusElement(t.focus)),t.native_click&&(s("[processQAAction] INJECT: Clicking on element before actions"),await e.clickElement(t.native_click)),t.keystroke!==void 0&&(s("[processQAAction] INJECT: Pressing key before script injection"),await e.pressKey(t.keystroke)),t.script&&await e.executeScript(t.script),await new Promise(o=>setTimeout(o,500)),!0;case"FINISH":return s("[processQAAction] FINISH: QA automation completed"),!1;default:throw new Error(`Unknown QA action: ${t.action}`)}}async getTool(){return this.tool.get(this.args["api-url"])}};var Qt=0,ue,de=new Ft({name:"evaluator-optimizer-mcp",version:G},{capabilities:{tools:{}}});de.setRequestHandler(Mt,async()=>{try{return{tools:[await ue.getTool()]}}catch(i){return s("FATAL ERROR!!! Failed to get tool definition:",i),{tools:[]}}});de.setRequestHandler(Bt,async i=>{let{name:t,arguments:e,_meta:r}=i.params,o=`req-${++Qt}-${Date.now()}`;$.initialize({progressToken:r?.progressToken,server:de}),$.toolCalled(),n.start("tool-call-handler",{uid:o,toolName:t});try{let a=await ue.getTool();if(t===a.name){s("=== Tool called ===");try{n.start("input-validation",{uid:o}),s("=== Validating tool-called input ===");let u=new zt,f=u.compile(a.inputSchema),l=f(e);if(n.end("input-validation",{uid:o,valid:l}),!l)throw n.end("tool-call-handler",{uid:o,result:"validation-failed"}),new y({confidence:1,feedbacks:[{text:"SYSTEM ERROR: Validation failed. FORBIDDEN to proceed.",structured:{violation:`VALIDATION_FAILURE: ${u.errorsText(f.errors)}`,testId:"N/A",penalty:"$1000"},suggestions:[{type:"action",content:"Fix validation errors and retry. NO EXCEPTIONS.",severity:"HIGH"}]}]});s("=== Tool-called input validated successfully: ==="),s(JSON.stringify(e,null,2)),$.toolValidated(),n.start("evaluation",{uid:o});let p=await ue.evaluate(e);return n.end("evaluation",{uid:o,decision:p.decision}),$.complete(),s("=== Evaluation completed: ==="),s(JSON.stringify(p,null,2)),n.end("tool-call-handler",{uid:o,result:"success"}),{content:[{type:"text",text:JSON.stringify(p,null,2)}]}}catch(u){n.end("evaluation",{uid:o,error:u.message}),n.end("tool-call-handler",{uid:o,error:u.message}),$.fail(u.message),s("=== ERROR in tool handler ==="),s(v(u));let f;return u instanceof y?f=u.toEvaluationResult():f={decision:"CRITIQUE",confidence:.1,feedbacks:[{text:"SYSTEM ERROR: Validation failed. FORBIDDEN to proceed.",structured:{violation:`VALIDATION_FAILURE: ${u.message||"Unknown error"}`,testId:"N/A",penalty:"$1000"},suggestions:[{type:"action",content:"Fix validation errors and retry. NO EXCEPTIONS.",severity:"HIGH"}]}],metadata:{evaluationTime:Date.now(),evaluatorVersion:G}},$.completeAfterFailure(),{content:[{type:"text",text:JSON.stringify(f,null,2)}]}}}}catch(a){n.end("tool-call-handler",{uid:o,error:a.message}),$.fail(a.message),$.completeAfterFailure(),s("FATAL ERROR!!! Failed to initialize tool:"),s(v(a))}throw $.fail(`Forbidden tool: ${t}`),$.completeAfterFailure(),new Error(`FORBIDDEN TOOL: ${t}`)});var rt=c(async(i,t)=>{ue=new ce(t),await de.connect(i),s(`Evaluator-Optimizer MCP Server v${G} running on stdio`)},"start");import Vt from"arg";var it=c(i=>{let t={"--start":{description:"Start with test number n (skip tests 1 to n-1). Must be \u2265 1.",context:["cli"],argDisplay:"--start n"},"--only":{description:"Run only test number n (if integer) or testId (if string). Cannot be used with --start or --ignore.",context:["cli"],argDisplay:"--only n|testId"},"--ignore":{description:"Ignore test with index n (if number) or testId (if string). Can be used multiple times.",context:["cli"],continuation:"Cannot be used with --only.",argDisplay:"--ignore n|id"},"--parallel":{description:"Set maximum parallel instances (default: auto-calculated). Must be \u2265 1.",context:["cli","server"],argDisplay:"--parallel n"},"--keep-alive":{description:"Keep process alive after evaluation (don't exit). Default: false.",context:["cli"],argDisplay:"--keep-alive"},"--fail-fast":{description:"Enable/disable fail-fast mode. Accepts: 'true', 'false', '1', '0'. Default: true.",context:["cli","server"],continuation:"When false, continues all tasks even if one fails.",argDisplay:"--fail-fast arg"},"--manual-filter":{description:"Show test selection UI in dashboard before running tests. Default: false.",context:["cli","server"],argDisplay:"--manual-filter"},"--test-timeout":{description:"Set test execution timeout in seconds. Default: 300 seconds (5 minutes).",context:["cli","server"],argDisplay:"--test-timeout n"},"--api-url":{description:'Override the API base URL. Default: "http://0.0.0.0:8000"',context:["cli","server"],argDisplay:"--api-url url"},"--output":{description:"Save evaluation results to JSON file instead of console output",context:["cli"],argDisplay:"--output filename.json"},"--help":{description:"Show this help message",context:["cli","server"],argDisplay:"--help"},"--no-headless":{description:"Show browser windows during QA automation (for debugging). Default: false.",context:["cli"],argDisplay:"--no-headless"},"--thinking-budget":{description:"Set thinking budget for evaluation processing. Accepts any integer (including 0 and -1).",context:["cli","server"],argDisplay:"--thinking-budget n"}},e=["\u2022 --start and --only cannot be used together","\u2022 --ignore cannot be used with --only","\u2022 All numeric parameters must be positive integers (\u2265 1)"];return{arguments:Object.entries(t).filter(([o,a])=>a.context.includes(i)).map(([o,a])=>({arg:o,argDisplay:a.argDisplay,description:a.description,continuation:a.continuation})),parameterRestrictions:i==="cli"?e:[]}},"getArgumentDescriptions"),ot=c(i=>{let t=Vt({"--start":Number,"--only":String,"--parallel":Number,"--test-timeout":Number,"--thinking-budget":Number,"--api-url":String,"--output":String,"--fail-fast":String,"--keep-alive":Boolean,"--help":Boolean,"--manual-filter":Boolean,"--no-headless":Boolean,"--ignore":[String]},{argv:i,permissive:!1}),e={_:t._,"api-url":"http://0.0.0.0:8000","fail-fast":!0,"keep-alive":!1,"manual-filter":!1,"no-headless":!1,"test-timeout":300};if(typeof t["--start"]<"u"){let r=t["--start"];if(isNaN(r)||r<1)throw new Error("--start parameter must be a positive number (1 or greater)");e.start=r,s(`Will start with test ${e.start} (skip tests 1-${e.start-1}) `)}if(typeof t["--only"]<"u"){let r=t["--only"];s("[parseCommandLineArgs] ========== Parsing --only parameter =========="),s(`[parseCommandLineArgs] Raw --only value: "${r}"`),s(`[parseCommandLineArgs] Type of --only value: ${typeof r}`);let o=parseInt(r,10);if(s(`[parseCommandLineArgs] Parsed numeric value: ${o}`),s(`[parseCommandLineArgs] Is numeric: ${!isNaN(o)}`),s(`[parseCommandLineArgs] Is positive: ${o>0}`),s(`[parseCommandLineArgs] String representation matches: ${o.toString()===r}`),!isNaN(o)&&o>0&&o.toString()===r)e.only=o,e.onlyIndex=o,s(`[parseCommandLineArgs] \u2705 Parsed --only as numeric index: ${e.only}`),s(`[parseCommandLineArgs] result.onlyIndex = ${e.onlyIndex}`);else if(r.trim().length>0)e.only=r,e.onlyTestId=r,s(`[parseCommandLineArgs] \u2705 Parsed --only as string testId: "${e.only}"`),s(`[parseCommandLineArgs] result.onlyTestId = "${e.onlyTestId}"`);else throw new Error("--only parameter must be a positive number (1 or greater) or a non-empty testId string");s("[parseCommandLineArgs] ========== End --only parameter parsing ==========")}else s("[parseCommandLineArgs] No --only parameter provided");if(typeof t["--parallel"]<"u"){let r=t["--parallel"];if(isNaN(r)||r<1)throw new Error("--parallel parameter must be a positive number (1 or greater)");e.parallel=r,s(`--parallel: Will run up to ${e.parallel} instances`)}if(typeof t["--test-timeout"]<"u"){let r=t["--test-timeout"];if(isNaN(r)||r<1)throw new Error("--test-timeout parameter must be a positive number (1 or greater)");e["test-timeout"]=r}if(s(`--test-timeout: Will use timeout of ${e["test-timeout"]} seconds`),t["--api-url"]&&(e["api-url"]=t["--api-url"]),s(`--api-url: Will use API base URL "${e["api-url"]}"`),t["--output"]&&(e.output=t["--output"],s(`--output: Will save results to JSON file "${e.output}"`)),typeof t["--keep-alive"]<"u"&&(e["keep-alive"]=t["--keep-alive"]),s(`--keep-alive: Will set keep alive to ${e["keep-alive"]}`),typeof t["--help"]<"u"&&(e.help=t["--help"]),typeof t["--manual-filter"]<"u"&&(e["manual-filter"]=t["--manual-filter"]),s(`--manual-filter: Manual filter mode: ${e["manual-filter"]?"enabled":"disabled"}`),typeof t["--no-headless"]<"u"&&(e["no-headless"]=t["--no-headless"]),s(`--no-headless: Browser visibility mode: ${e["no-headless"]?"enabled (browsers visible)":"disabled (headless)"}`),typeof t["--thinking-budget"]<"u"){let r=t["--thinking-budget"];if(isNaN(r))throw new Error("--thinking-budget parameter must be a valid number");e["thinking-budget"]=r,s(`--thinking-budget: Will use thinking budget of ${e["thinking-budget"]}`)}if(t["--ignore"]){let r=t["--ignore"],o=[],a=[];for(let u of r){let f=parseInt(u,10);!isNaN(f)&&f>0?o.push(f):a.push(u)}e.ignoreIndices=o,s(`Will ignore test indices: ${e.ignoreIndices.join(", ")}`),e.ignoreStrings=a,s(`Will ignore test IDs: ${e.ignoreStrings.join(", ")}`)}if(typeof t["--fail-fast"]<"u"){let r=t["--fail-fast"];if(r==="false"||r==="0")e["fail-fast"]=!1;else if(r==="true"||r==="1")e["fail-fast"]=!0;else throw new Error("Invalid value for --fail-fast: must be 'true', 'false', '1', or '0'")}if(s(`Fail-fast mode: ${e["fail-fast"]?"enabled":"disabled"}`),e.start!==void 0&&e.only!==void 0)throw new Error("--start and --only parameters cannot be used together");if(e.only!==void 0&&(e.ignoreIndices?.length||e.ignoreStrings?.length))throw new Error("--ignore parameters cannot be used with --only");return e},"parseCommandLineArgs");function jt(){console.log(`
Usage: mcp-evaluator-optimizer [options]

MCP Server for evaluating and optimizing MCP server implementations.

Server Options:`),it("server").arguments.forEach(({argDisplay:i,description:t,continuation:e})=>{console.log(`  ${i.padEnd(18)} ${t}`),e&&console.log(`                     ${e}`)}),console.log(`

Note: This is the MCP server. For CLI evaluation tool, use:
  node dist/cli --help
`)}c(jt,"showServerHelp");var Wt=c(async()=>{let i=ot(process.argv.slice(2));i.help&&(jt(),process.exit(0));let t=new Gt;await rt(t,i)},"start");Wt().catch(async i=>{s("Server error:",i),await B.cleanup(),process.exit(1)});export{v as stringifyError};
